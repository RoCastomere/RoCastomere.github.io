<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>十大排序算法</title>
    <link href="undefined2020/04/04/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>2020/04/04/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="十大排序算法"><a href="#十大排序算法" class="headerlink" title="十大排序算法"></a><strong>十大排序算法</strong></h1><hr><p><strong><em>我们这里统一写由小到大排序</em></strong></p><hr><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><p><strong>复杂度：O(n^2)</strong></p><p>算法：当相邻的两项a[i] &gt; a[j] 且 i &lt; j 时，交换相邻两项</p><pre><code class="C++">int n;int a[maxn];for(int i = n ; i &gt;= 1 ; i--){ // 判断结尾位置    for(int j = 2 ; j &lt;= i ; j++){ // 内部进行冒泡排序         if(a[j-1] &gt; a[j]){            swap(a[j-1] , a[j]);        }    }}</code></pre><hr><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h3><p><strong><em>复杂度：O(n^2)</em></strong></p><p>选择剩余元素中最小or最大的，和当前位置进行交换</p><pre><code class="C++">//maxn = 1e5 , inf = 由题意决定，这里当做1e18int n;int a[maxn];for(int i = 1 ; i &lt;= n ; i++){ //枚举需要被替换的位置    int id = -1;    int Min = inf;    for(int j = i ; j &lt;= n ; j++){ //枚举，找到被选择数字的下标        if(Min &gt; a[j]){            id = j;            Min = a[j]        }    }    swap(a[i] , a[id]); //交换}</code></pre><hr><h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h3><p><strong><em>复杂度：最好O(n)，最坏O(n^2)——倒序数组</em></strong></p><p>构建已排序序列，在已排序中从后向前，找到位置并插入数据</p><pre><code class="C++">int n;int a[maxn];for(int i = 1 ; i &lt;= n ; i++){    int id = i; 寻找的插入位置    for(int j = i-1 ; j &gt;= 1 ; j--){        if(a[i] &gt;= a[j]){        // 找到一个a[j] &lt;= a[j]，将a[i]放到它后面，退出循环            a[j+1] = a[i];            break;        } else {            a[j+1] = a[j]; // 比a[i] 大的向后挪        }    }}</code></pre><hr><h3 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h3><p><strong><em>时间复杂度：最坏O(n^2),最好O(n)</em></strong></p><p>通过确定K个增量t1，t2…tk,对按增量划分的 子序列 进行插入排序</p><p>(取出所有间隔tk-1的项，进行插入排序)</p><pre><code class="C++">int n;int a[maxn];for(int gap = n/2 ; gap &gt; 0 ; gap /= 2){    //增量是gap，每次变为之前的 1/2    for(int i = gap ; i &lt;= len ; i++){        int x = a[i] , id = i;        for(int j = i ; j - gap &gt;= 0 &amp;&amp; x &lt;= a[j-gap] ; j -= gap , id = j){            a[j] = a[j-gap];        }        a[j] = x;    }}</code></pre><hr><h3 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h3><p><strong><em>时间复杂度O(nlogn)</em></strong></p><p>每次对一段区间 一分为二，直到为区间长度为 1，每次向上有序合并区间 </p><pre><code class="C++">int n;int a[maxn];void MergeSort(int l, int r, int len){ //初始传入 (1 , n , n)     if(len &lt;= 1) return;    int mid = (l + r) &gt;&gt; 1;    MergeSort(l, mid, mid-l+1);    MergeSort(mid+1, r, r-mid);    int t[maxn] , cnt= 0;    int dl = mid-l+1 , dr = r-mid;    whle(dl &amp;&amp; dr){        int c1 = a[mid-dl+1] , c2 = a[r-dr+1];        if(c1 &lt;= c2){            t[++cnt] = c[mid-dl+1];            dl--;        } else {            t[++cnt] = c[r-dr+1];            dr--;        }    }    while(dl){        t[++cnt] = c[mid-dl+1];        dl--;    }    while(dr){        t[++cnt] = c[r-dr+1];        dr--;    }    for(int i = l , j = 1; i &lt;= r ; i++ , j++){        a[i] = t[j];    }}</code></pre><hr><h3 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h3><p><strong><em>时间复杂度：最慢O(n^2),最快O(nlogn)</em></strong></p><p>一个区间，选择基准值，比它小的放前面，大的放后面</p><p>然后递归实现，减小这种区间的大小</p><pre><code class="C++">void quicksort(int arr[] , int i , int j){    if(i &gt; j)    return;    int mid = arr[j]; // 选择基准值    int l = i , r = j - 1; //基准值之外的区间    while(l &lt; r){        while(arr[l] &lt; mid &amp;&amp; l &lt; r) l++; // 左边区间比它小的忽略        while(arr[r] &gt;= mid &amp;&amp; l &lt; r) r--; // 右边比它大的忽略        swap(arr[l] , arr[r]); // 找到的不能忽略的两个值，交换    }    if(arr[l] &gt;= arr[j])    swap(arr[l] , arr[j]); // 看a[l] 这个位置和基准值比大小，并且交换    else l++;    //下层递归    if(l)    quicksort(arr , i , l - 1);    quicksort(arr , l + 1 , j);}</code></pre><hr><h3 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h3><p><strong><em>时间复杂度O(nlogn)</em></strong></p><pre><code class="C++">int n , len;int a[maxn];void heapify(int i){    int rt = i, ls = i * 2 + 1, rs = i * 2 + 2;    if(ls &lt; len &amp;&amp; a[ls] &gt; a[rt]){        rt = rt;    }    if(rs &lt; len &amp;&amp; a[rs] &gt; a[rt]){        rs = rt;    }    if(rt != i){        swap(a[i] , a[rt]);        heapify(rt);    }}void Build(){    for(int i = n/2 ; i&gt;= 0 ; i--){        heapify(i); // 堆调整    }}void heapSort(){    Build();    len = n;    for(int i = n-1 ; i &gt; 0 ; i--){        swap(a[0] , a[i]);        len--;        heapify(0);    }}</code></pre><hr><h3 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8. 计数排序"></a>8. 计数排序</h3><p><strong><em>时间复杂度O(n)</em></strong></p><p>一种利用额外空间vis[]，对已知数组每个数 计数的方式，然后从小到大，线性输出</p><p>要求排序有范围，让vis可以进行标记，如果数字超出vis标记，用map or 哈希方法，对应计数</p><pre><code class="C++">int n;int vis[maxn];int a[maxn];for(int i = 1 ; i &lt;= n ; i++){    vis[a[i]]++;}int ans[maxn] , tot = 0;for(int i = 1 ; i &lt;= maxn ; i++){    while(vis[i]--){        ans[++tot] = i;    }}</code></pre><hr><h3 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9. 桶排序"></a>9. 桶排序</h3><p><strong><em>时间复杂度：最坏O(n^2),最好O(n)</em></strong></p><p>假设数据服从均匀分布，选一个定量数组当空桶，每个桶内排序，最后扫一遍数组</p><p>实现方法：</p><p>用d进制分桶，i次桶排排倒数第i位，对第i+1位桶排，每一个桶都是后i位有序的</p><hr><h3 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10. 基数排序"></a>10. 基数排序</h3><p><strong><em>复杂度：O(nk) , k进制</em></strong></p><p>基数排序是按照低位先排序，然后收集；</p><p>再按照高位排序，然后再收集；</p><p>依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>怎么使用markdown + 刷新blog</title>
    <link href="undefined2020/04/04/%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8markdown-%E5%88%B7%E6%96%B0blog/"/>
    <url>2020/04/04/%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8markdown-%E5%88%B7%E6%96%B0blog/</url>
    
    <content type="html"><![CDATA[<ul><li><h1 id="learn-markdown"><a href="#learn-markdown" class="headerlink" title="learn markdown"></a>learn markdown</h1></li></ul><pre><code># 标题,共有6级标题**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~&gt; 是引用 有无限层 &quot;&gt;&gt;&gt;&gt;&quot;这种--- or *** 是分割线![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加(需要图床)[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加无序列表- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格，无序列表用 - + * 任何一种都可以有序列表1. 列表内容2. 列表内容3. 列表内容注意：序号跟内容之间要有空格列表嵌套上一级和下一级之间敲三个空格即可eg :- xx   - xx      - xx 表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略单行代码：代码之间分别用一个反引号包起来`代码内容`代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行(``` 这个位置输入你的代码语言，进行高亮提示注意没有小括号，为防转移使用(```流程图，其实可以用图片做</code></pre><hr><ul><li><h1 id="Terminal内执行下面语句"><a href="#Terminal内执行下面语句" class="headerlink" title="Terminal内执行下面语句"></a>Terminal内执行下面语句</h1><pre><code class="aidl">hexo cleanhexo generatehexo server</code></pre></li></ul><pre><code>- #### 写博客本地预览```aidlhexo new &quot;new markdown file name&quot;hexo server</code></pre><ul><li><h4 id="部署到远端"><a href="#部署到远端" class="headerlink" title="部署到远端"></a>部署到远端</h4><pre><code class="aidl">hexo g   //生成网页hexo d  //部署到远端(github)</code></pre></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="undefined2019/11/16/hello-world/"/>
    <url>2019/11/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>